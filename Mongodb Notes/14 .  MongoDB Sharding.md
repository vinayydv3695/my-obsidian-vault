

# # **1. What is Sharding?**

Sharding = **horizontal scaling** in MongoDB.

### **Purpose**

- Distribute large data sets across multiple servers
    
- Improve read/write throughput
    
- Prevent single-node bottlenecks
    

### **Each shard is a replica set**

Meaning:

- High availability
    
- Redundancy
    
- Automatic failover
    

---

# ---------------------------------------------------------

# # **2. Sharding Architecture Components**

### **1. mongos (Query Router)**

- Application connects to **mongos**, not directly to shards.
    
- Routes queries to target shard(s).
    
- Knows chunk locations and metadata.
    

### **2. Config Servers (CSRS)**

Store:

- Chunk ranges
    
- Shard key definition
    
- Shard mapping
    
- Database → primary shard mapping
    

**These are critical nodes.** Cluster fails if config servers fail.

### **3. Shards**

- Each shard is a **replica set**
    
- Stores actual collection data
    
- Contains **chunks**, each chunk is a data range
    

### **Important Note**

Not all collections must be sharded.  
Each database has a **primary shard** where non-sharded collections live.

---

# ---------------------------------------------------------

# # **3. Data Partitioning (Chunks)**

- Data is partitioned into **chunks** based on a shard key.
    
- **Balancer** migrates chunks between shards to maintain even distribution.
    

### **Example:**

```js
sh.shardCollection("db.collection", { userId: 1 })
```

---

# ---------------------------------------------------------

# # **4. Choosing a Shard Key**

Picking the correct shard key is the **most important design decision**.

### **Important Factors**

#### **1. Cardinality**

- Number of unique values
    
- High cardinality → more possible chunk splits → better scaling
    

#### **2. Frequency**

- How often a shard key value appears
    
- High-frequency values → hotspots → uneven distribution
    

#### **3. Monotonicity**

- Insert operations trend in one direction (increasing IDs, timestamps)
    
- Causes **hot shard problem**
    
- Use **hashed keys** to avoid this
    

### **Ideal Shard Key Qualities**

- High cardinality
    
- Low frequency
    
- Non-monotonic
    
- Well aligned with query patterns
    

---

# ---------------------------------------------------------

# # **5. Sharding Strategies**

### **1. Range Sharding**

- Chunks split by ranges
    
- Good for range queries
    
- Risk: **Hotspot formation** (new inserts fall into same range)
    

### **2. Hashed Sharding**

- Field → hashed → evenly distributed
    
- Best for writes
    
- Range queries become inefficient
    

### **3. Zoned Sharding (Tag Aware Sharding)**

- Assign ranges to specific physical shards
    
- Useful for:
    
    - Geo-locality requirements
        
    - Compliance (e.g., EU data must stay in EU)
        
- Uses:
    
    - `sh.addShardToZone()`
        
    - `sh.updateZoneKeyRange()`
        

---

# ---------------------------------------------------------

# # **6. Initial Chunk Distribution**

### **Populated Collections (already have data)**

- Shard operation splits existing data
    
- Balancer redistributes chunks
    

### **Empty Collections**

- MongoDB can **pre-split** chunks
    
- Avoids sudden hotspot loads
    

Zones also influence initial chunk placement.

---

# ---------------------------------------------------------

# # **7. Resharding Process**

Resharding = changing the shard key.

### **Steps**

1. Build new sharded collection with new key
    
2. Copy data into it
    
3. Sync subsequent writes
    
4. Commit new key
    
5. Drop original sharded data
    

**Online operation** → Minimal downtime.

---

# ---------------------------------------------------------

# # **8. Refining a Shard Key**

- Append new fields to existing shard key
    
- Lightweight alternative to full resharding
    
- Improves:
    
    - Query targeting
        
    - Data distribution
        
    - Hotspot reduction
        

---

# ---------------------------------------------------------

# # **9. Sharding Best Practices**

- Choose shard key with high cardinality & low frequency
    
- Avoid monotonically increasing shard keys (unless hashed)
    
- Pre-split large collections
    
- Understand most common queries
    
- Use:
    
    - `analyzeShardKey`
        
    - `configureQueryAnalyzer`  
        for data-driven selection
        
- Plan zones in advance
    

---

# ---------------------------------------------------------

# # ⭐ **20 MCQs Based on MongoDB Sharding (Questions + Options + Answers)**

---

### **1. Sharding in MongoDB refers to:**

A) Vertical scaling  
B) Horizontal scaling  
C) Backup creation  
D) Query optimization  
**Answer: B**

---

### **2. Which component routes queries in a sharded cluster?**

A) mongod  
B) config server  
C) mongos  
D) routerd  
**Answer: C**

---

### **3. Config servers store:**

A) User accounts  
B) Chunk metadata and shard key info  
C) Actual data  
D) Backups  
**Answer: B**

---

### **4. Each shard in MongoDB is usually a:**

A) Single mongod instance  
B) Node with no replication  
C) Replica set  
D) Cache layer  
**Answer: C**

---

### **5. Chunk movement between shards is handled by:**

A) mongos  
B) oplog  
C) balancer  
D) config server  
**Answer: C**

---

### **6. Shard key cardinality refers to:**

A) Number of fields in document  
B) Uniqueness of shard key values  
C) Data types supported  
D) Sorting order  
**Answer: B**

---

### **7. High-frequency shard key values lead to:**

A) Faster balancing  
B) Hotspots  
C) Better query targeting  
D) No impact  
**Answer: B**

---

### **8. A monotonic shard key typically causes:**

A) Even data distribution  
B) Network failures  
C) Inserts piling onto one shard  
D) Index drop  
**Answer: C**

---

### **9. Best for evenly distributing writes:**

A) Range sharding  
B) Hashed sharding  
C) Zoned sharding  
D) TTL sharding  
**Answer: B**

---

### **10. Range sharding is best for:**

A) High-throughput writes  
B) Range queries  
C) Random reads  
D) Aggregation merges  
**Answer: B**

---

### **11. Zoned sharding is used for:**

A) Full-text search  
B) Data locality compliance  
C) Transaction routing  
D) File storage  
**Answer: B**

---

### **12. Command to shard a collection:**

A) sh.enable()  
B) sh.partitionCollection()  
C) sh.shardCollection()  
D) rs.shard()  
**Answer: C**

---

### **13. To add a shard to a zone:**

A) sh.addShard()  
B) sh.updateZone()  
C) sh.addShardToZone()  
D) sh.zoneShard()  
**Answer: C**

---

### **14. In an empty collection, MongoDB can:**

A) Disable chunk creation  
B) Pre-split chunks  
C) Denormalize documents  
D) Pre-allocate oplog  
**Answer: B**

---

### **15. Resharding requires:**

A) Full downtime  
B) Offline migration  
C) Copying data into a new sharded collection  
D) Dropping indexes  
**Answer: C**

---

### **16. Refining a shard key means:**

A) Choosing a brand-new shard key  
B) Appending fields to existing shard key  
C) Dropping existing shard key  
D) Removing sharding  
**Answer: B**

---

### **17. A good shard key generally has:**

A) Low cardinality, high frequency  
B) High cardinality, low frequency  
C) Monotonic values  
D) Duplicate values  
**Answer: B**

---

### **18. Which sharding strategy helps avoid monotonic insert hotspots?**

A) Range  
B) Zoned  
C) Hashed  
D) TTL  
**Answer: C**

---

### **19. Primary shard stores:**

A) Only sharded collections  
B) Only indexes  
C) All unsharded collections  
D) Only oplog  
**Answer: C**

---

### **20. Tool recommended for choosing shard key using real data:**

A) analyzeShardKey  
B) shardAnalyzer  
C) keyInspector  
D) queryKeyTool  
**Answer: A**

---

